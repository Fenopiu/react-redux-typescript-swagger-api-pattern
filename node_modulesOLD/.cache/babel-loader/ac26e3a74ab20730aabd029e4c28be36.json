{"ast":null,"code":"import _objectSpread from \"/Users/luca/Documents/GitHub/react-redux-typescript-swagger-api-pattern/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\n\n/**\n * Functions for sending OAuth2 requests to the server.\n */\n\n/** The authentication module config, with default values.\n * Use the setConfig method to update the config.\n */\nlet config = {\n  apiBase: '/auth',\n  clientId: 'test',\n  clientSecret: 'secret'\n};\n/** How many seconds before the access token expires do we refresh it */\n\nconst REFRESH_TOKEN_WINDOW = 60;\n\nfunction fetchAccessToken(options) {\n  return fetch(config.apiBase + '/token', options).then(response => {\n    if (response.ok) {\n      return response.json();\n    } else {\n      let contentType = response.headers.get('Content-Type');\n\n      if (contentType && contentType.indexOf('json') !== -1) {\n        return response.json().then(msg => {\n          if (msg.error) {\n            throw new Error('Auth request failed: ' + msg.error);\n          } else {\n            throw new Error('Auth request failed: ' + response.statusText);\n          }\n        });\n      } else {\n        throw new Error('Auth request failed: ' + response.statusText);\n      }\n    }\n  }).then(json => json).then(accessToken => {\n    /* Add the refreshAt date to the token, so we know when to refresh it */\n    return _objectSpread({}, accessToken, {\n      refreshAt: Date.now() + (accessToken.expires_in - REFRESH_TOKEN_WINDOW) * 1000\n    });\n  });\n}\n/** Attempt to obtain an AccessToken with the given credentials. */\n\n\nexport function authenticate(username, password) {\n  let formData = new URLSearchParams();\n  formData.append('client_id', config.clientId);\n  formData.append('client_secret', config.clientSecret);\n  formData.append('grant_type', 'password');\n  formData.append('username', username);\n  formData.append('password', password);\n  let options = {\n    method: 'POST',\n    body: formData\n  };\n  return fetchAccessToken(options);\n}\n/** Attempt to refresh the AccessToken using the given refresh token.\n * Returns a new AccessToken.\n */\n\nexport function refresh(refreshToken) {\n  let formData = new URLSearchParams();\n  formData.append('client_id', config.clientId);\n  formData.append('client_secret', config.clientSecret);\n  formData.append('grant_type', 'refresh_token');\n  formData.append('refresh_token', refreshToken);\n  let options = {\n    method: 'POST',\n    body: formData\n  };\n  return fetchAccessToken(options);\n}\nexport function setConfig(newConfig) {\n  config = newConfig;\n}","map":{"version":3,"sources":["/Users/luca/Documents/GitHub/react-redux-typescript-swagger-api-pattern/src/modules/auth/functions.ts"],"names":["config","apiBase","clientId","clientSecret","REFRESH_TOKEN_WINDOW","fetchAccessToken","options","fetch","then","response","ok","json","contentType","headers","get","indexOf","msg","error","Error","statusText","accessToken","refreshAt","Date","now","expires_in","authenticate","username","password","formData","URLSearchParams","append","method","body","refresh","refreshToken","setConfig","newConfig"],"mappings":"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","sourcesContent":["/**\n * Functions for sending OAuth2 requests to the server.\n */\n\nimport { AccessToken, Config } from './types';\n\n/** The authentication module config, with default values.\n * Use the setConfig method to update the config.\n */\nlet config: Config = {\n    apiBase: '/auth',\n    clientId: 'test',\n    clientSecret: 'secret',\n};\n\n/** How many seconds before the access token expires do we refresh it */\nconst REFRESH_TOKEN_WINDOW = 60;\n\nfunction fetchAccessToken(options: RequestInit): Promise<AccessToken> {\n    return fetch(config.apiBase + '/token', options)\n        .then(response => {\n            if (response.ok) {\n                return response.json();\n            } else {\n                let contentType = response.headers.get('Content-Type');\n                if (contentType && contentType.indexOf('json') !== -1) {\n                    return response.json().then(msg => {\n                        if (msg.error) {\n                            throw new Error('Auth request failed: ' + msg.error);\n                        } else {\n                            throw new Error('Auth request failed: ' + response.statusText);\n                        }\n                    });\n                } else {\n                    throw new Error('Auth request failed: ' + response.statusText);\n                }\n            }\n        })\n        .then(json => json as AccessToken)\n        .then(accessToken => {\n            /* Add the refreshAt date to the token, so we know when to refresh it */\n            return {\n                ...accessToken,\n                refreshAt: Date.now() + (accessToken.expires_in - REFRESH_TOKEN_WINDOW) * 1000,\n            } as AccessToken;\n        });\n}\n\n/** Attempt to obtain an AccessToken with the given credentials. */\nexport function authenticate(username: string, password: string): Promise<AccessToken> {\n    let formData = new URLSearchParams();\n    formData.append('client_id', config.clientId);\n    formData.append('client_secret', config.clientSecret);\n    formData.append('grant_type', 'password');\n    formData.append('username', username);\n    formData.append('password', password);\n\n    let options: RequestInit = {\n        method: 'POST',\n        body: formData\n    };\n    return fetchAccessToken(options);\n}\n\n/** Attempt to refresh the AccessToken using the given refresh token.\n * Returns a new AccessToken.\n */\nexport function refresh(refreshToken: string): Promise<AccessToken> {\n    let formData = new URLSearchParams();\n    formData.append('client_id', config.clientId);\n    formData.append('client_secret', config.clientSecret);\n    formData.append('grant_type', 'refresh_token');\n    formData.append('refresh_token', refreshToken);\n\n    let options: RequestInit = {\n        method: 'POST',\n        body: formData\n    };\n    return fetchAccessToken(options);\n}\n\nexport function setConfig(newConfig: Config) {\n    config = newConfig;\n}\n"]},"metadata":{},"sourceType":"module"}